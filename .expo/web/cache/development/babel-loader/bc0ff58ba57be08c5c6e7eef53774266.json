{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _jsxFileName = \"/Users/olivermou/Documents/GitHub/aicare/node_modules/react-native-image-view/src/ImageView.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from 'react';\nimport ActivityIndicator from \"react-native-web/dist/exports/ActivityIndicator\";\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport FlatList from \"react-native-web/dist/exports/FlatList\";\nimport Modal from \"react-native-web/dist/exports/Modal\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport View from \"react-native-web/dist/exports/View\";\nimport SafeAreaView from \"react-native-web/dist/exports/SafeAreaView\";\nimport { addIndexesToImages, calculateInitialTranslate, fetchImageSize, generatePanHandlers, getImagesWithoutSize, getScale, getDistance, getInitialParams, hexToRgb, isHex, scalesAreEqual } from \"./utils\";\nimport createStyles from \"./styles\";\nimport { Close, Prev, Next } from \"./controls\";\nvar IMAGE_SPEED_FOR_CLOSE = 1.1;\nvar SCALE_MAXIMUM = 5;\nvar HEADER_HEIGHT = 60;\nvar SCALE_MAX_MULTIPLIER = 3;\nvar FREEZE_SCROLL_DISTANCE = 15;\nvar BACKGROUND_OPACITY_MULTIPLIER = 0.003;\nvar defaultBackgroundColor = [0, 0, 0];\n\nvar getScreenDimensions = function getScreenDimensions() {\n  return {\n    screenWidth: Dimensions.get('window').width,\n    screenHeight: Dimensions.get('window').height\n  };\n};\n\nvar styles = createStyles(getScreenDimensions());\n\nvar ImageView = function (_Component) {\n  _inherits(ImageView, _Component);\n\n  var _super = _createSuper(ImageView);\n\n  function ImageView(props) {\n    var _this;\n\n    _classCallCheck(this, ImageView);\n\n    _this = _super.call(this, props);\n\n    _this.onChangeDimension = function (_ref) {\n      var window = _ref.window;\n      var screenDimensions = {\n        screenWidth: window.width,\n        screenHeight: window.height\n      };\n\n      _this.setState({\n        screenDimensions: screenDimensions\n      });\n\n      styles = createStyles(screenDimensions);\n\n      _this.onNextImagesReceived(_this.props.images, _this.state.imageIndex);\n    };\n\n    _this.onFlatListRender = function (flatListRef) {\n      var _this$state = _this.state,\n          images = _this$state.images,\n          imageIndex = _this$state.imageIndex,\n          isFlatListRerendered = _this$state.isFlatListRerendered;\n\n      if (flatListRef && !isFlatListRerendered) {\n        _this.listRef = flatListRef;\n\n        _this.setState({\n          isFlatListRerendered: true\n        });\n\n        if (images.length > 0) {\n          var nextTick = new Promise(function (resolve) {\n            return setTimeout(resolve, 0);\n          });\n          nextTick.then(function () {\n            flatListRef.scrollToIndex({\n              index: imageIndex,\n              animated: false\n            });\n          });\n        }\n      }\n    };\n\n    _this.onNextImage = function (event) {\n      var imageIndex = _this.state.imageIndex;\n\n      var _ref2 = event.nativeEvent.contentOffset || {\n        x: 0\n      },\n          x = _ref2.x;\n\n      var nextImageIndex = Math.round(x / _this.state.screenDimensions.screenWidth);\n      _this.isScrolling = Math.ceil(x) % _this.state.screenDimensions.screenWidth > 10;\n\n      if (imageIndex !== nextImageIndex && nextImageIndex >= 0) {\n        var nextImageScale = _this.getInitialScale(nextImageIndex);\n\n        var nextImageTranslate = _this.getInitialTranslate(nextImageIndex);\n\n        _this.setState({\n          imageIndex: nextImageIndex,\n          imageScale: nextImageScale,\n          imageTranslate: nextImageTranslate\n        });\n\n        _this.imageScaleValue.setValue(nextImageScale);\n\n        _this.imageTranslateValue.setValue(nextImageTranslate);\n\n        if (typeof _this.props.onImageChange === 'function') {\n          _this.props.onImageChange(nextImageIndex);\n        }\n      }\n    };\n\n    _this.onMomentumScrollBegin = function () {\n      _this.isScrolling = true;\n\n      if (_this.glideAlwaysTimer) {\n        clearTimeout(_this.glideAlwaysTimer);\n      }\n    };\n\n    _this.onMomentumScrollEnd = function () {\n      _this.isScrolling = false;\n    };\n\n    _this.getItemLayout = function (_, index) {\n      var screenWidth = _this.state.screenDimensions.screenWidth;\n      return {\n        length: screenWidth,\n        offset: screenWidth * index,\n        index: index\n      };\n    };\n\n    _this.getControls = function () {\n      var _this$props$controls = _this.props.controls,\n          close = _this$props$controls.close,\n          prev = _this$props$controls.prev,\n          next = _this$props$controls.next;\n      var controls = {\n        close: Close,\n        prev: undefined,\n        next: undefined\n      };\n\n      if (close === null) {\n        controls.close = null;\n      }\n\n      if (close) {\n        controls.close = close === true ? Close : close;\n      }\n\n      if (prev) {\n        controls.prev = prev === true ? Prev : prev;\n      }\n\n      if (next) {\n        controls.next = next === true ? Next : next;\n      }\n\n      return controls;\n    };\n\n    _this.setSizeForImages = function (nextImages) {\n      if (nextImages.length === 0) {\n        return [];\n      }\n\n      var images = _this.state.images;\n      return images.map(function (image, index) {\n        var nextImageSize = nextImages.find(function (nextImage) {\n          return nextImage.index === index;\n        });\n\n        if (nextImageSize) {\n          image.width = nextImageSize.width;\n          image.height = nextImageSize.height;\n        }\n\n        return image;\n      });\n    };\n\n    _this.scrollToNext = function () {\n      if (_this.listRef && typeof _this.listRef.scrollToIndex === 'function') {\n        _this.listRef.scrollToIndex({\n          index: _this.state.imageIndex + 1,\n          animated: true\n        });\n      }\n    };\n\n    _this.scrollToPrev = function () {\n      if (_this.listRef && typeof _this.listRef.scrollToIndex === 'function') {\n        _this.listRef.scrollToIndex({\n          index: _this.state.imageIndex - 1,\n          animated: true\n        });\n      }\n    };\n\n    _this.listKeyExtractor = function (image) {\n      return _this.state.images.indexOf(image).toString();\n    };\n\n    _this.close = function () {\n      _this.setState({\n        isVisible: false\n      });\n\n      if (typeof _this.props.onClose === 'function') {\n        _this.props.onClose();\n      }\n    };\n\n    _this.renderImage = function (_ref3) {\n      var image = _ref3.item,\n          index = _ref3.index;\n      var loaded = image.loaded && image.width && image.height;\n      return React.createElement(View, {\n        style: styles.imageContainer,\n        onStartShouldSetResponder: function onStartShouldSetResponder() {\n          return true;\n        },\n        __self: _assertThisInitialized(_this),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 737,\n          columnNumber: 13\n        }\n      }, React.createElement(Animated.Image, _extends({\n        resizeMode: \"cover\",\n        source: image.source,\n        style: _this.getImageStyle(image, index),\n        onLoad: function onLoad() {\n          return _this.onImageLoaded(index);\n        }\n      }, _this.panResponder.panHandlers, {\n        __self: _assertThisInitialized(_this),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 741,\n          columnNumber: 17\n        }\n      })), !loaded && React.createElement(ActivityIndicator, {\n        style: styles.loading,\n        __self: _assertThisInitialized(_this),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 748,\n          columnNumber: 29\n        }\n      }));\n    };\n\n    var initialScreenDimensions = getScreenDimensions();\n    _this.imageInitialParams = props.images.map(function (image) {\n      return getInitialParams(image, initialScreenDimensions);\n    });\n    _this.state = {\n      images: props.images,\n      isVisible: props.isVisible,\n      imageIndex: props.imageIndex,\n      imageScale: 1,\n      imageTranslate: {\n        x: 0,\n        y: 0\n      },\n      scrollEnabled: true,\n      panelsVisible: true,\n      isFlatListRerendered: false,\n      screenDimensions: initialScreenDimensions\n    };\n    _this.glideAlwaysTimer = null;\n    _this.listRef = null;\n    _this.isScrolling = false;\n    _this.footerHeight = 0;\n    _this.initialTouches = [];\n    _this.currentTouchesNum = 0;\n    _this.doubleTapTimer = null;\n    _this.modalAnimation = new Animated.Value(0);\n    _this.modalBackgroundOpacity = new Animated.Value(0);\n    _this.headerTranslateValue = new Animated.ValueXY();\n    _this.footerTranslateValue = new Animated.ValueXY();\n    _this.imageScaleValue = new Animated.Value(_this.getInitialScale());\n\n    var _this$getInitialTrans = _this.getInitialTranslate(),\n        _x = _this$getInitialTrans.x,\n        y = _this$getInitialTrans.y;\n\n    _this.imageTranslateValue = new Animated.ValueXY({\n      x: _x,\n      y: y\n    });\n    _this.panResponder = generatePanHandlers(function (event) {\n      return _this.onGestureStart(event.nativeEvent);\n    }, function (event, gestureState) {\n      return _this.onGestureMove(event.nativeEvent, gestureState);\n    }, function (event, gestureState) {\n      return _this.onGestureRelease(event.nativeEvent, gestureState);\n    });\n    var imagesWithoutSize = getImagesWithoutSize(addIndexesToImages(props.images));\n\n    if (imagesWithoutSize.length) {\n      Promise.all(fetchImageSize(imagesWithoutSize)).then(_this.setSizeForImages);\n    }\n\n    return _this;\n  }\n\n  _createClass(ImageView, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      styles = createStyles(this.state.screenDimensions);\n      Dimensions.addEventListener('change', this.onChangeDimension);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      var _this2 = this;\n\n      var _this$state2 = this.state,\n          images = _this$state2.images,\n          imageIndex = _this$state2.imageIndex,\n          isVisible = _this$state2.isVisible;\n\n      if (typeof this.props.isVisible !== 'undefined' && this.props.isVisible !== isVisible) {\n        this.onNextImagesReceived(this.props.images, this.props.imageIndex);\n\n        if (images !== this.props.images || imageIndex !== this.props.imageIndex) {\n          var imagesWithoutSize = getImagesWithoutSize(addIndexesToImages(this.props.images));\n\n          if (imagesWithoutSize.length) {\n            Promise.all(fetchImageSize(imagesWithoutSize)).then(function (updatedImages) {\n              return _this2.onNextImagesReceived(_this2.setSizeForImages(updatedImages), _this2.props.imageIndex);\n            });\n          }\n        }\n\n        this.setState({\n          isVisible: this.props.isVisible,\n          isFlatListRerendered: false\n        });\n        this.modalBackgroundOpacity.setValue(0);\n\n        if (this.props.isVisible) {\n          Animated.timing(this.modalAnimation, {\n            duration: 400,\n            toValue: 1\n          }).start();\n        }\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      Dimensions.removeEventListener('change', this.onChangeDimension);\n\n      if (this.glideAlwaysTimer) {\n        clearTimeout(this.glideAlwaysTimer);\n      }\n    }\n  }, {\n    key: \"onNextImagesReceived\",\n    value: function onNextImagesReceived(images) {\n      var _this3 = this;\n\n      var imageIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      this.imageInitialParams = images.map(function (image) {\n        return getInitialParams(image, _this3.state.screenDimensions);\n      });\n\n      var _ref4 = this.imageInitialParams[imageIndex] || {\n        scale: 1,\n        translate: {}\n      },\n          scale = _ref4.scale,\n          translate = _ref4.translate;\n\n      this.setState({\n        images: images,\n        imageIndex: imageIndex,\n        imageScale: scale,\n        imageTranslate: translate,\n        isFlatListRerendered: false\n      });\n      this.imageScaleValue.setValue(scale);\n      this.imageTranslateValue.setValue(translate);\n    }\n  }, {\n    key: \"onGestureStart\",\n    value: function onGestureStart(event) {\n      this.initialTouches = event.touches;\n      this.currentTouchesNum = event.touches.length;\n    }\n  }, {\n    key: \"onGestureMove\",\n    value: function onGestureMove(event, gestureState) {\n      if (this.isScrolling && this.state.scrollEnabled) {\n        return;\n      }\n\n      if (this.currentTouchesNum === 1 && event.touches.length === 2) {\n        this.initialTouches = event.touches;\n      }\n\n      var _this$props = this.props,\n          isSwipeCloseEnabled = _this$props.isSwipeCloseEnabled,\n          isPinchZoomEnabled = _this$props.isPinchZoomEnabled;\n      var _this$state3 = this.state,\n          images = _this$state3.images,\n          imageIndex = _this$state3.imageIndex,\n          imageScale = _this$state3.imageScale,\n          imageTranslate = _this$state3.imageTranslate,\n          screenDimensions = _this$state3.screenDimensions;\n      var screenHeight = screenDimensions.screenHeight;\n      var touches = event.touches;\n      var x = imageTranslate.x,\n          y = imageTranslate.y;\n      var dx = gestureState.dx,\n          dy = gestureState.dy;\n      var imageInitialScale = this.getInitialScale();\n      var height = images[imageIndex].height;\n\n      if (imageScale !== imageInitialScale) {\n        this.imageTranslateValue.x.setValue(x + dx);\n      }\n\n      if (imageScale * height > screenHeight) {\n        this.imageTranslateValue.y.setValue(y + dy);\n      }\n\n      if (isSwipeCloseEnabled && scalesAreEqual(imageScale, imageInitialScale) && height * imageInitialScale < screenHeight) {\n        var backgroundOpacity = Math.abs(dy * BACKGROUND_OPACITY_MULTIPLIER);\n        this.imageTranslateValue.y.setValue(y + dy);\n        this.modalBackgroundOpacity.setValue(backgroundOpacity > 1 ? 1 : backgroundOpacity);\n      }\n\n      var currentDistance = getDistance(touches);\n      var initialDistance = getDistance(this.initialTouches);\n      var scrollEnabled = Math.abs(dy) < FREEZE_SCROLL_DISTANCE;\n      this.setState({\n        scrollEnabled: scrollEnabled\n      });\n\n      if (!initialDistance) {\n        return;\n      }\n\n      if (!isPinchZoomEnabled || touches.length < 2) {\n        return;\n      }\n\n      var nextScale = getScale(currentDistance, initialDistance) * imageScale;\n\n      if (nextScale < imageInitialScale) {\n        nextScale = imageInitialScale;\n      } else if (nextScale > SCALE_MAXIMUM) {\n        nextScale = SCALE_MAXIMUM;\n      }\n\n      this.imageScaleValue.setValue(nextScale);\n      this.currentTouchesNum = event.touches.length;\n    }\n  }, {\n    key: \"onGestureRelease\",\n    value: function onGestureRelease(event, gestureState) {\n      var _this4 = this;\n\n      if (this.glideAlwaysTimer) {\n        clearTimeout(this.glideAlwaysTimer);\n      }\n\n      if (this.props.glideAlways && Platform.OS === 'android') {\n        this.glideAlwaysTimer = setTimeout(function () {\n          _this4.glideAlwaysTimer = null;\n\n          if (_this4.listRef && _this4.listRef.scrollToIndex) {\n            _this4.listRef.scrollToIndex({\n              index: _this4.state.imageIndex,\n              animated: true\n            });\n          }\n        }, this.props.glideAlwaysDelay);\n      }\n\n      if (this.isScrolling) {\n        return;\n      }\n\n      var imageScale = this.state.imageScale;\n      var _this$props2 = this.props,\n          isSwipeCloseEnabled = _this$props2.isSwipeCloseEnabled,\n          isTapZoomEnabled = _this$props2.isTapZoomEnabled;\n      var scale = this.imageScaleValue._value;\n      var modalBackgroundOpacity = this.modalBackgroundOpacity._value;\n      var dx = gestureState.dx,\n          dy = gestureState.dy,\n          vy = gestureState.vy;\n      var imageInitialScale = this.getInitialScale();\n      var imageInitialTranslate = this.getInitialTranslate();\n\n      if (event && !dx && !dy && scalesAreEqual(imageScale, scale)) {\n        if (isTapZoomEnabled && this.doubleTapTimer) {\n          clearTimeout(this.doubleTapTimer);\n          this.doubleTapTimer = null;\n          scale = scalesAreEqual(imageInitialScale, scale) ? scale * SCALE_MAX_MULTIPLIER : imageInitialScale;\n          Animated.timing(this.imageScaleValue, {\n            toValue: scale,\n            duration: 300\n          }).start();\n          this.togglePanels(scale === imageInitialScale);\n        } else {\n          this.doubleTapTimer = setTimeout(function () {\n            _this4.togglePanels();\n\n            _this4.doubleTapTimer = null;\n          }, 200);\n        }\n      }\n\n      var _this$calculateNextTr = this.calculateNextTranslate(dx, dy, scale),\n          x = _this$calculateNextTr.x,\n          y = _this$calculateNextTr.y;\n\n      var scrollEnabled = scale === this.getInitialScale() && x === imageInitialTranslate.x && y === imageInitialTranslate.y;\n      Animated.parallel([modalBackgroundOpacity > 0 ? Animated.timing(this.modalBackgroundOpacity, {\n        toValue: 0,\n        duration: 100\n      }) : null, Animated.timing(this.imageTranslateValue.x, {\n        toValue: x,\n        duration: 100\n      }), Animated.timing(this.imageTranslateValue.y, {\n        toValue: y,\n        duration: 100\n      })].filter(Boolean)).start();\n\n      if (isSwipeCloseEnabled && scale === imageInitialScale && Math.abs(vy) >= IMAGE_SPEED_FOR_CLOSE) {\n        Animated.timing(this.imageTranslateValue.y, {\n          toValue: y + 400 * vy,\n          duration: 150\n        }).start(this.close);\n      }\n\n      this.setState({\n        imageScale: scale,\n        imageTranslate: {\n          x: x,\n          y: y\n        },\n        scrollEnabled: scrollEnabled\n      });\n    }\n  }, {\n    key: \"onImageLoaded\",\n    value: function onImageLoaded(index) {\n      var images = this.state.images;\n      images[index] = _objectSpread(_objectSpread({}, images[index]), {}, {\n        loaded: true\n      });\n      this.setState({\n        images: images\n      });\n    }\n  }, {\n    key: \"getInitialScale\",\n    value: function getInitialScale(index) {\n      var imageIndex = index !== undefined ? index : this.state.imageIndex;\n      var imageParams = this.imageInitialParams[imageIndex];\n      return imageParams ? imageParams.scale : 1;\n    }\n  }, {\n    key: \"getInitialTranslate\",\n    value: function getInitialTranslate(index) {\n      var imageIndex = index !== undefined ? index : this.state.imageIndex;\n      var imageParams = this.imageInitialParams[imageIndex];\n      return imageParams ? imageParams.translate : {\n        x: 0,\n        y: 0\n      };\n    }\n  }, {\n    key: \"getImageStyle\",\n    value: function getImageStyle(image, index) {\n      var _this$state4 = this.state,\n          imageIndex = _this$state4.imageIndex,\n          screenDimensions = _this$state4.screenDimensions;\n      var width = image.width,\n          height = image.height;\n\n      if (!width || !height) {\n        return {\n          opacity: 0\n        };\n      }\n\n      var _calculateInitialTran = calculateInitialTranslate(width, height + 1, screenDimensions),\n          x = _calculateInitialTran.x,\n          y = _calculateInitialTran.y;\n\n      var translateValue = new Animated.ValueXY({\n        x: x,\n        y: y\n      });\n      var transform = index === imageIndex ? this.imageTranslateValue.getTranslateTransform() : translateValue.getTranslateTransform();\n      var scale = index === imageIndex ? this.imageScaleValue : this.getInitialScale(index);\n      transform.push({\n        scale: scale\n      });\n      return {\n        width: width,\n        height: height,\n        transform: transform\n      };\n    }\n  }, {\n    key: \"calculateNextTranslate\",\n    value: function calculateNextTranslate(dx, dy, scale) {\n      var _this$state5 = this.state,\n          images = _this$state5.images,\n          imageIndex = _this$state5.imageIndex,\n          imageTranslate = _this$state5.imageTranslate,\n          screenDimensions = _this$state5.screenDimensions;\n      var x = imageTranslate.x,\n          y = imageTranslate.y;\n      var screenWidth = screenDimensions.screenWidth,\n          screenHeight = screenDimensions.screenHeight;\n      var _images$imageIndex = images[imageIndex],\n          width = _images$imageIndex.width,\n          height = _images$imageIndex.height;\n      var imageInitialScale = this.getInitialScale();\n\n      var getTranslate = function getTranslate(axis) {\n        var imageSize = axis === 'x' ? width : height;\n        var screenSize = axis === 'x' ? screenWidth : screenHeight;\n        var leftLimit = (scale * imageSize - imageSize) / 2;\n        var rightLimit = screenSize - imageSize - leftLimit;\n        var nextTranslate = axis === 'x' ? x + dx : y + dy;\n\n        if (screenSize > scale * imageSize) {\n          if (width >= height) {\n            nextTranslate = (screenSize - imageSize) / 2;\n          } else {\n            nextTranslate = screenSize / 2 - imageSize * (scale / imageInitialScale) / 2;\n          }\n\n          return nextTranslate;\n        }\n\n        if (nextTranslate > leftLimit) {\n          nextTranslate = leftLimit;\n        }\n\n        if (nextTranslate < rightLimit) {\n          nextTranslate = rightLimit;\n        }\n\n        return nextTranslate;\n      };\n\n      return {\n        x: getTranslate('x'),\n        y: getTranslate('y')\n      };\n    }\n  }, {\n    key: \"togglePanels\",\n    value: function togglePanels(isVisible) {\n      var panelsVisible = typeof isVisible !== 'undefined' ? isVisible : !this.state.panelsVisible;\n      this.setState({\n        panelsVisible: panelsVisible\n      });\n      Animated.timing(this.headerTranslateValue.y, {\n        toValue: !panelsVisible ? -(HEADER_HEIGHT + 44) : 0,\n        duration: 200,\n        useNativeDriver: true\n      }).start();\n\n      if (this.footerHeight > 0) {\n        Animated.timing(this.footerTranslateValue.y, {\n          toValue: !panelsVisible ? this.footerHeight : 0,\n          duration: 200,\n          useNativeDriver: true\n        }).start();\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this5 = this;\n\n      var _this$props3 = this.props,\n          animationType = _this$props3.animationType,\n          renderFooter = _this$props3.renderFooter,\n          backgroundColor = _this$props3.backgroundColor;\n      var _this$state6 = this.state,\n          images = _this$state6.images,\n          imageIndex = _this$state6.imageIndex,\n          imageScale = _this$state6.imageScale,\n          isVisible = _this$state6.isVisible,\n          scrollEnabled = _this$state6.scrollEnabled;\n\n      var _this$getControls = this.getControls(),\n          close = _this$getControls.close,\n          prev = _this$getControls.prev,\n          next = _this$getControls.next;\n\n      var imageInitialScale = this.getInitialScale();\n      var headerTranslate = this.headerTranslateValue.getTranslateTransform();\n      var footerTranslate = this.footerTranslateValue.getTranslateTransform();\n      var rgbBackgroundColor = backgroundColor && isHex(backgroundColor) ? hexToRgb(backgroundColor) : defaultBackgroundColor;\n      var rgb = rgbBackgroundColor.join(',');\n      var animatedBackgroundColor = this.modalBackgroundOpacity.interpolate({\n        inputRange: [0, 1],\n        outputRange: [\"rgba(\" + rgb + \", 0.9)\", \"rgba(\" + rgb + \", 0.2)\"]\n      });\n      var isPrevVisible = imageScale === imageInitialScale && imageIndex > 0;\n      var isNextVisible = imageScale === imageInitialScale && imageIndex < images.length - 1;\n      return React.createElement(Modal, {\n        transparent: true,\n        visible: isVisible,\n        animationType: animationType,\n        onRequestClose: this.close,\n        supportedOrientations: ['portrait', 'landscape'],\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 785,\n          columnNumber: 13\n        }\n      }, React.createElement(Animated.View, {\n        style: [{\n          backgroundColor: animatedBackgroundColor\n        }, styles.underlay],\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 792,\n          columnNumber: 17\n        }\n      }), React.createElement(Animated.View, {\n        style: [styles.header, {\n          transform: headerTranslate\n        }],\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 798,\n          columnNumber: 17\n        }\n      }, React.createElement(SafeAreaView, {\n        style: {\n          flex: 1\n        },\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 806,\n          columnNumber: 21\n        }\n      }, !!close && React.createElement(close, {\n        onPress: this.close\n      }))), React.createElement(FlatList, {\n        horizontal: true,\n        pagingEnabled: true,\n        data: images,\n        scrollEnabled: scrollEnabled,\n        scrollEventThrottle: 16,\n        style: styles.container,\n        ref: this.onFlatListRender,\n        renderSeparator: function renderSeparator() {\n          return null;\n        },\n        keyExtractor: this.listKeyExtractor,\n        onScroll: this.onNextImage,\n        renderItem: this.renderImage,\n        getItemLayout: this.getItemLayout,\n        onMomentumScrollBegin: this.onMomentumScrollBegin,\n        onMomentumScrollEnd: this.onMomentumScrollEnd,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 811,\n          columnNumber: 17\n        }\n      }), prev && isPrevVisible && React.createElement(prev, {\n        onPress: this.scrollToPrev\n      }), next && isNextVisible && React.createElement(next, {\n        onPress: this.scrollToNext\n      }), renderFooter && React.createElement(Animated.View, {\n        style: [styles.footer, {\n          transform: footerTranslate\n        }],\n        onLayout: function onLayout(event) {\n          _this5.footerHeight = event.nativeEvent.layout.height;\n        },\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 834,\n          columnNumber: 21\n        }\n      }, typeof renderFooter === 'function' && images[imageIndex] && renderFooter(images[imageIndex])));\n    }\n  }]);\n\n  return ImageView;\n}(Component);\n\nImageView.defaultProps = {\n  backgroundColor: null,\n  images: [],\n  imageIndex: 0,\n  isTapZoomEnabled: true,\n  isPinchZoomEnabled: true,\n  isSwipeCloseEnabled: true,\n  glideAlways: false,\n  glideAlwaysDelay: 75,\n  controls: {\n    prev: null,\n    next: null\n  }\n};\nexport { ImageView as default };","map":{"version":3,"sources":["/Users/olivermou/Documents/GitHub/aicare/node_modules/react-native-image-view/src/ImageView.js"],"names":["React","Component","addIndexesToImages","calculateInitialTranslate","fetchImageSize","generatePanHandlers","getImagesWithoutSize","getScale","getDistance","getInitialParams","hexToRgb","isHex","scalesAreEqual","createStyles","Close","Prev","Next","IMAGE_SPEED_FOR_CLOSE","SCALE_MAXIMUM","HEADER_HEIGHT","SCALE_MAX_MULTIPLIER","FREEZE_SCROLL_DISTANCE","BACKGROUND_OPACITY_MULTIPLIER","defaultBackgroundColor","getScreenDimensions","screenWidth","Dimensions","get","width","screenHeight","height","styles","ImageView","props","onChangeDimension","window","screenDimensions","setState","onNextImagesReceived","images","state","imageIndex","onFlatListRender","flatListRef","isFlatListRerendered","listRef","length","nextTick","Promise","resolve","setTimeout","then","scrollToIndex","index","animated","onNextImage","event","nativeEvent","contentOffset","x","nextImageIndex","Math","round","isScrolling","ceil","nextImageScale","getInitialScale","nextImageTranslate","getInitialTranslate","imageScale","imageTranslate","imageScaleValue","setValue","imageTranslateValue","onImageChange","onMomentumScrollBegin","glideAlwaysTimer","clearTimeout","onMomentumScrollEnd","getItemLayout","_","offset","getControls","controls","close","prev","next","undefined","setSizeForImages","nextImages","map","image","nextImageSize","find","nextImage","scrollToNext","scrollToPrev","listKeyExtractor","indexOf","toString","isVisible","onClose","renderImage","item","loaded","imageContainer","source","getImageStyle","onImageLoaded","panResponder","panHandlers","loading","initialScreenDimensions","imageInitialParams","y","scrollEnabled","panelsVisible","footerHeight","initialTouches","currentTouchesNum","doubleTapTimer","modalAnimation","Animated","Value","modalBackgroundOpacity","headerTranslateValue","ValueXY","footerTranslateValue","onGestureStart","gestureState","onGestureMove","onGestureRelease","imagesWithoutSize","all","addEventListener","updatedImages","timing","duration","toValue","start","removeEventListener","scale","translate","touches","isSwipeCloseEnabled","isPinchZoomEnabled","dx","dy","imageInitialScale","backgroundOpacity","abs","currentDistance","initialDistance","nextScale","glideAlways","Platform","OS","glideAlwaysDelay","isTapZoomEnabled","_value","vy","imageInitialTranslate","togglePanels","calculateNextTranslate","parallel","filter","Boolean","imageParams","opacity","translateValue","transform","getTranslateTransform","push","getTranslate","axis","imageSize","screenSize","leftLimit","rightLimit","nextTranslate","useNativeDriver","animationType","renderFooter","backgroundColor","headerTranslate","footerTranslate","rgbBackgroundColor","rgb","join","animatedBackgroundColor","interpolate","inputRange","outputRange","isPrevVisible","isNextVisible","underlay","header","flex","createElement","onPress","container","footer","layout","defaultProps"],"mappings":"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","sourcesContent":["// @flow\n\nimport React, {Component, type Node, type ComponentType} from 'react';\nimport {\n    ActivityIndicator,\n    Animated,\n    Dimensions,\n    FlatList,\n    Modal,\n    Platform,\n    View,\n    SafeAreaView,\n} from 'react-native';\n\nimport {\n    type ControlType,\n    type ControlsType,\n    type DimensionsType,\n    type EventType,\n    type ImageType,\n    type ImageSizeType,\n    type GestureState,\n    type NativeEventType,\n    type TouchType,\n    type TransitionType,\n    type TranslateType,\n} from './types';\n\nimport {\n    addIndexesToImages,\n    calculateInitialTranslate,\n    fetchImageSize,\n    generatePanHandlers,\n    getImagesWithoutSize,\n    getScale,\n    getDistance,\n    getInitialParams,\n    hexToRgb,\n    isHex,\n    scalesAreEqual,\n} from './utils';\n\nimport createStyles from './styles';\nimport {Close, Prev, Next} from './controls';\n\nconst IMAGE_SPEED_FOR_CLOSE = 1.1;\nconst SCALE_MAXIMUM = 5;\nconst HEADER_HEIGHT = 60;\nconst SCALE_MAX_MULTIPLIER = 3;\nconst FREEZE_SCROLL_DISTANCE = 15;\nconst BACKGROUND_OPACITY_MULTIPLIER = 0.003;\nconst defaultBackgroundColor = [0, 0, 0];\n\nconst getScreenDimensions = () => ({\n    screenWidth: Dimensions.get('window').width,\n    screenHeight: Dimensions.get('window').height,\n});\n\nlet styles = createStyles(getScreenDimensions());\n\ntype PropsType = {\n    animationType: 'none' | 'fade' | 'slide',\n    backgroundColor?: string,\n    glideAlways?: boolean,\n    glideAlwaysDelay?: number,\n    images: ImageType[],\n    imageIndex: number,\n    isVisible: boolean,\n    isTapZoomEnabled: boolean,\n    isPinchZoomEnabled: boolean,\n    isSwipeCloseEnabled: boolean,\n    onClose: () => {},\n    onImageChange: number => {},\n    renderFooter: ImageType => {},\n    controls: {\n        close?: ComponentType<ControlType> | boolean,\n        next?: ComponentType<ControlType> | boolean,\n        prev?: ComponentType<ControlType> | boolean,\n    },\n};\n\nexport type StateType = {\n    images: ImageType[],\n    isVisible: boolean,\n    imageIndex: number,\n    imageScale: number,\n    imageTranslate: {x: number, y: number},\n    scrollEnabled: boolean,\n    panelsVisible: boolean,\n    isFlatListRerendered: boolean,\n    screenDimensions: {screenWidth: number, screenHeight: number},\n};\n\nexport default class ImageView extends Component<PropsType, StateType> {\n    static defaultProps = {\n        backgroundColor: null,\n        images: [],\n        imageIndex: 0,\n        isTapZoomEnabled: true,\n        isPinchZoomEnabled: true,\n        isSwipeCloseEnabled: true,\n        glideAlways: false,\n        glideAlwaysDelay: 75,\n        controls: {prev: null, next: null},\n    };\n\n    constructor(props: PropsType) {\n        super(props);\n\n        // calculate initial scale and translate for images\n        const initialScreenDimensions = getScreenDimensions();\n        this.imageInitialParams = props.images.map(image =>\n            getInitialParams(image, initialScreenDimensions)\n        );\n\n        this.state = {\n            images: props.images,\n            isVisible: props.isVisible,\n            imageIndex: props.imageIndex,\n            imageScale: 1,\n            imageTranslate: {x: 0, y: 0},\n            scrollEnabled: true,\n            panelsVisible: true,\n            isFlatListRerendered: false,\n            screenDimensions: initialScreenDimensions,\n        };\n        this.glideAlwaysTimer = null;\n        this.listRef = null;\n        this.isScrolling = false;\n        this.footerHeight = 0;\n        this.initialTouches = [];\n        this.currentTouchesNum = 0;\n        this.doubleTapTimer = null;\n        this.modalAnimation = new Animated.Value(0);\n        this.modalBackgroundOpacity = new Animated.Value(0);\n\n        this.headerTranslateValue = new Animated.ValueXY();\n        this.footerTranslateValue = new Animated.ValueXY();\n\n        this.imageScaleValue = new Animated.Value(this.getInitialScale());\n        const {x, y} = this.getInitialTranslate();\n        this.imageTranslateValue = new Animated.ValueXY({x, y});\n\n        this.panResponder = generatePanHandlers(\n            (event: EventType): void => this.onGestureStart(event.nativeEvent),\n            (event: EventType, gestureState: GestureState): void =>\n                this.onGestureMove(event.nativeEvent, gestureState),\n            (event: EventType, gestureState: GestureState): void =>\n                this.onGestureRelease(event.nativeEvent, gestureState)\n        );\n\n        const imagesWithoutSize = getImagesWithoutSize(\n            addIndexesToImages(props.images)\n        );\n\n        if (imagesWithoutSize.length) {\n            Promise.all(fetchImageSize(imagesWithoutSize)).then(\n                this.setSizeForImages\n            );\n        }\n    }\n\n    componentDidMount() {\n        styles = createStyles(this.state.screenDimensions);\n        Dimensions.addEventListener('change', this.onChangeDimension);\n    }\n\n    componentDidUpdate() {\n        const {images, imageIndex, isVisible} = this.state;\n\n        if (\n            typeof this.props.isVisible !== 'undefined' &&\n            this.props.isVisible !== isVisible\n        ) {\n            this.onNextImagesReceived(this.props.images, this.props.imageIndex);\n\n            if (\n                images !== this.props.images ||\n                imageIndex !== this.props.imageIndex\n            ) {\n                const imagesWithoutSize = getImagesWithoutSize(\n                    addIndexesToImages(this.props.images)\n                );\n\n                if (imagesWithoutSize.length) {\n                    Promise.all(fetchImageSize(imagesWithoutSize)).then(\n                        updatedImages =>\n                            this.onNextImagesReceived(\n                                this.setSizeForImages(updatedImages),\n                                this.props.imageIndex\n                            )\n                    );\n                }\n            }\n\n            this.setState({\n                isVisible: this.props.isVisible,\n                isFlatListRerendered: false,\n            });\n\n            this.modalBackgroundOpacity.setValue(0);\n\n            if (this.props.isVisible) {\n                Animated.timing(this.modalAnimation, {\n                    duration: 400,\n                    toValue: 1,\n                }).start();\n            }\n        }\n    }\n\n    componentWillUnmount() {\n        Dimensions.removeEventListener('change', this.onChangeDimension);\n\n        if (this.glideAlwaysTimer) {\n            clearTimeout(this.glideAlwaysTimer);\n        }\n    }\n\n    onChangeDimension = ({window}: {window: DimensionsType}) => {\n        const screenDimensions = {\n            screenWidth: window.width,\n            screenHeight: window.height,\n        };\n\n        this.setState({screenDimensions});\n        styles = createStyles(screenDimensions);\n\n        this.onNextImagesReceived(this.props.images, this.state.imageIndex);\n    };\n\n    onNextImagesReceived(images: Array<ImageType>, imageIndex: number = 0) {\n        this.imageInitialParams = images.map(image =>\n            getInitialParams(image, this.state.screenDimensions)\n        );\n        const {scale, translate} = this.imageInitialParams[imageIndex] || {\n            scale: 1,\n            translate: {},\n        };\n\n        this.setState({\n            images,\n            imageIndex,\n            imageScale: scale,\n            imageTranslate: translate,\n            isFlatListRerendered: false,\n        });\n\n        this.imageScaleValue.setValue(scale);\n        this.imageTranslateValue.setValue(translate);\n    }\n\n    // $FlowFixMe\n    onFlatListRender = flatListRef => {\n        const {images, imageIndex, isFlatListRerendered} = this.state;\n\n        if (flatListRef && !isFlatListRerendered) {\n            this.listRef = flatListRef;\n            this.setState({\n                isFlatListRerendered: true,\n            });\n\n            // Fix for android https://github.com/facebook/react-native/issues/13202\n            if (images.length > 0) {\n                const nextTick = new Promise(resolve => setTimeout(resolve, 0));\n                nextTick.then(() => {\n                    flatListRef.scrollToIndex({\n                        index: imageIndex,\n                        animated: false,\n                    });\n                });\n            }\n        }\n    };\n\n    onNextImage = (event: EventType) => {\n        const {imageIndex} = this.state;\n        const {x} = event.nativeEvent.contentOffset || {x: 0};\n\n        const nextImageIndex = Math.round(\n            x / this.state.screenDimensions.screenWidth\n        );\n\n        this.isScrolling =\n            Math.ceil(x) % this.state.screenDimensions.screenWidth > 10;\n\n        if (imageIndex !== nextImageIndex && nextImageIndex >= 0) {\n            const nextImageScale = this.getInitialScale(nextImageIndex);\n            const nextImageTranslate = this.getInitialTranslate(nextImageIndex);\n\n            this.setState({\n                imageIndex: nextImageIndex,\n                imageScale: nextImageScale,\n                imageTranslate: nextImageTranslate,\n            });\n\n            this.imageScaleValue.setValue(nextImageScale);\n            this.imageTranslateValue.setValue(nextImageTranslate);\n\n            if (typeof this.props.onImageChange === 'function') {\n                this.props.onImageChange(nextImageIndex);\n            }\n        }\n    };\n\n    onGestureStart(event: NativeEventType) {\n        this.initialTouches = event.touches;\n        this.currentTouchesNum = event.touches.length;\n    }\n\n    /**\n     * If image is moved from its original position\n     * then disable scroll (for ScrollView)\n     */\n    onGestureMove(event: NativeEventType, gestureState: GestureState) {\n        if (this.isScrolling && this.state.scrollEnabled) {\n            return;\n        }\n\n        if (this.currentTouchesNum === 1 && event.touches.length === 2) {\n            this.initialTouches = event.touches;\n        }\n\n        const {isSwipeCloseEnabled, isPinchZoomEnabled} = this.props;\n\n        const {\n            images,\n            imageIndex,\n            imageScale,\n            imageTranslate,\n            screenDimensions,\n        } = this.state;\n        const {screenHeight} = screenDimensions;\n        const {touches} = event;\n        const {x, y} = imageTranslate;\n        const {dx, dy} = gestureState;\n        const imageInitialScale = this.getInitialScale();\n        const {height} = images[imageIndex];\n\n        if (imageScale !== imageInitialScale) {\n            this.imageTranslateValue.x.setValue(x + dx);\n        }\n\n        // Do not allow to move image vertically until it fits to the screen\n        if (imageScale * height > screenHeight) {\n            this.imageTranslateValue.y.setValue(y + dy);\n        }\n\n        // if image not scaled and fits to the screen\n        if (\n            isSwipeCloseEnabled &&\n            scalesAreEqual(imageScale, imageInitialScale) &&\n            height * imageInitialScale < screenHeight\n        ) {\n            const backgroundOpacity = Math.abs(\n                dy * BACKGROUND_OPACITY_MULTIPLIER\n            );\n\n            this.imageTranslateValue.y.setValue(y + dy);\n            this.modalBackgroundOpacity.setValue(\n                backgroundOpacity > 1 ? 1 : backgroundOpacity\n            );\n        }\n\n        const currentDistance = getDistance(touches);\n        const initialDistance = getDistance(this.initialTouches);\n\n        const scrollEnabled = Math.abs(dy) < FREEZE_SCROLL_DISTANCE;\n        this.setState({scrollEnabled});\n\n        if (!initialDistance) {\n            return;\n        }\n\n        if (!isPinchZoomEnabled || touches.length < 2) {\n            return;\n        }\n\n        let nextScale = getScale(currentDistance, initialDistance) * imageScale;\n\n        if (nextScale < imageInitialScale) {\n            nextScale = imageInitialScale;\n        } else if (nextScale > SCALE_MAXIMUM) {\n            nextScale = SCALE_MAXIMUM;\n        }\n\n        this.imageScaleValue.setValue(nextScale);\n        this.currentTouchesNum = event.touches.length;\n    }\n\n    onGestureRelease(event: NativeEventType, gestureState: GestureState) {\n        if (this.glideAlwaysTimer) {\n            clearTimeout(this.glideAlwaysTimer);\n        }\n\n        if (this.props.glideAlways && Platform.OS === 'android') {\n            this.glideAlwaysTimer = setTimeout(() => {\n                this.glideAlwaysTimer = null;\n                // If standard glide is not triggered then emulate it\n                // $FlowFixMe\n                if (this.listRef && this.listRef.scrollToIndex) {\n                    this.listRef.scrollToIndex({\n                        index: this.state.imageIndex,\n                        animated: true,\n                    });\n                }\n            }, this.props.glideAlwaysDelay);\n        }\n\n        if (this.isScrolling) {\n            return;\n        }\n\n        const {imageScale} = this.state;\n        const {isSwipeCloseEnabled, isTapZoomEnabled} = this.props;\n\n        let {_value: scale} = this.imageScaleValue;\n        const {_value: modalBackgroundOpacity} = this.modalBackgroundOpacity;\n\n        const {dx, dy, vy} = gestureState;\n        const imageInitialScale = this.getInitialScale();\n        const imageInitialTranslate = this.getInitialTranslate();\n\n        // Position haven't changed, so it just tap\n        if (event && !dx && !dy && scalesAreEqual(imageScale, scale)) {\n            // Double tap timer is launched, its double tap\n\n            if (isTapZoomEnabled && this.doubleTapTimer) {\n                clearTimeout(this.doubleTapTimer);\n                this.doubleTapTimer = null;\n\n                scale = scalesAreEqual(imageInitialScale, scale)\n                    ? scale * SCALE_MAX_MULTIPLIER\n                    : imageInitialScale;\n\n                Animated.timing(this.imageScaleValue, {\n                    toValue: scale,\n                    duration: 300,\n                }).start();\n\n                this.togglePanels(scale === imageInitialScale);\n            } else {\n                this.doubleTapTimer = setTimeout(() => {\n                    this.togglePanels();\n                    this.doubleTapTimer = null;\n                }, 200);\n            }\n        }\n\n        const {x, y} = this.calculateNextTranslate(dx, dy, scale);\n        const scrollEnabled =\n            scale === this.getInitialScale() &&\n            x === imageInitialTranslate.x &&\n            y === imageInitialTranslate.y;\n\n        Animated.parallel(\n            [\n                modalBackgroundOpacity > 0\n                    ? Animated.timing(this.modalBackgroundOpacity, {\n                          toValue: 0,\n                          duration: 100,\n                      })\n                    : null,\n                Animated.timing(this.imageTranslateValue.x, {\n                    toValue: x,\n                    duration: 100,\n                }),\n                Animated.timing(this.imageTranslateValue.y, {\n                    toValue: y,\n                    duration: 100,\n                }),\n            ].filter(Boolean)\n        ).start();\n\n        // Close modal with animation if image not scaled and high vertical gesture speed\n        if (\n            isSwipeCloseEnabled &&\n            scale === imageInitialScale &&\n            Math.abs(vy) >= IMAGE_SPEED_FOR_CLOSE\n        ) {\n            Animated.timing(this.imageTranslateValue.y, {\n                toValue: y + 400 * vy,\n                duration: 150,\n            }).start(this.close);\n        }\n\n        this.setState({\n            imageScale: scale,\n            imageTranslate: {x, y},\n            scrollEnabled,\n        });\n    }\n\n    onImageLoaded(index: number) {\n        const {images} = this.state;\n\n        images[index] = {...images[index], loaded: true};\n\n        this.setState({images});\n    }\n\n    onMomentumScrollBegin = () => {\n        this.isScrolling = true;\n        if (this.glideAlwaysTimer) {\n            // If FlatList started gliding then prevent glideAlways scrolling\n            clearTimeout(this.glideAlwaysTimer);\n        }\n    };\n\n    onMomentumScrollEnd = () => {\n        this.isScrolling = false;\n    };\n\n    getItemLayout = (_: *, index: number): Object => {\n        const {screenWidth} = this.state.screenDimensions;\n\n        return {length: screenWidth, offset: screenWidth * index, index};\n    };\n\n    getInitialScale(index?: number): number {\n        const imageIndex = index !== undefined ? index : this.state.imageIndex;\n        const imageParams = this.imageInitialParams[imageIndex];\n\n        return imageParams ? imageParams.scale : 1;\n    }\n\n    getInitialTranslate(index?: number): TranslateType {\n        const imageIndex = index !== undefined ? index : this.state.imageIndex;\n        const imageParams = this.imageInitialParams[imageIndex];\n\n        return imageParams ? imageParams.translate : {x: 0, y: 0};\n    }\n\n    getImageStyle(\n        image: ImageType,\n        index: number\n    ): {width?: number, height?: number, transform?: any, opacity?: number} {\n        const {imageIndex, screenDimensions} = this.state;\n        const {width, height} = image;\n\n        if (!width || !height) {\n            return {opacity: 0};\n        }\n\n        // very strange caching, fix it with changing size to 1 pixel\n        const {x, y} = calculateInitialTranslate(\n            width,\n            height + 1,\n            screenDimensions\n        );\n        const translateValue = new Animated.ValueXY({x, y});\n\n        const transform =\n            index === imageIndex\n                ? this.imageTranslateValue.getTranslateTransform()\n                : translateValue.getTranslateTransform();\n\n        const scale =\n            index === imageIndex\n                ? this.imageScaleValue\n                : this.getInitialScale(index);\n        // $FlowFixMe\n        transform.push({scale});\n\n        return {width, height, transform};\n    }\n\n    getControls = (): ControlsType => {\n        const {close, prev, next} = this.props.controls;\n        const controls = {close: Close, prev: undefined, next: undefined};\n\n        if (close === null) {\n            controls.close = null;\n        }\n\n        if (close) {\n            controls.close = close === true ? Close : close;\n        }\n\n        if (prev) {\n            controls.prev = prev === true ? Prev : prev;\n        }\n\n        if (next) {\n            controls.next = next === true ? Next : next;\n        }\n\n        return controls;\n    };\n\n    setSizeForImages = (nextImages: Array<ImageSizeType>): Array<ImageType> => {\n        if (nextImages.length === 0) {\n            return [];\n        }\n\n        const {images} = this.state;\n\n        return images.map((image, index) => {\n            const nextImageSize = nextImages.find(\n                nextImage => nextImage.index === index\n            );\n\n            /* eslint-disable */\n            if (nextImageSize) {\n                image.width = nextImageSize.width;\n                image.height = nextImageSize.height;\n            }\n            /* eslint-enable */\n\n            return image;\n        });\n    };\n\n    scrollToNext = () => {\n        if (this.listRef && typeof this.listRef.scrollToIndex === 'function') {\n            this.listRef.scrollToIndex({\n                index: this.state.imageIndex + 1,\n                animated: true,\n            });\n        }\n    };\n\n    scrollToPrev = () => {\n        if (this.listRef && typeof this.listRef.scrollToIndex === 'function') {\n            this.listRef.scrollToIndex({\n                index: this.state.imageIndex - 1,\n                animated: true,\n            });\n        }\n    };\n\n    imageInitialParams: TransitionType[];\n    glideAlwaysTimer: ?TimeoutID;\n    listRef: *;\n    isScrolling: boolean;\n    footerHeight: number;\n    initialTouches: TouchType[];\n    currentTouchesNum: number;\n    doubleTapTimer: ?TimeoutID;\n    modalAnimation: *;\n    modalBackgroundOpacity: *;\n    headerTranslateValue: *;\n    footerTranslateValue: *;\n    imageScaleValue: *;\n    imageTranslateValue: *;\n    panResponder: *;\n\n    calculateNextTranslate(\n        dx: number,\n        dy: number,\n        scale: number\n    ): {x: number, y: number} {\n        const {\n            images,\n            imageIndex,\n            imageTranslate,\n            screenDimensions,\n        } = this.state;\n        const {x, y} = imageTranslate;\n        const {screenWidth, screenHeight} = screenDimensions;\n        const {width, height} = images[imageIndex];\n        const imageInitialScale = this.getInitialScale();\n\n        const getTranslate = (axis: string): number => {\n            const imageSize = axis === 'x' ? width : height;\n            const screenSize = axis === 'x' ? screenWidth : screenHeight;\n            const leftLimit = (scale * imageSize - imageSize) / 2;\n            const rightLimit = screenSize - imageSize - leftLimit;\n\n            let nextTranslate = axis === 'x' ? x + dx : y + dy;\n\n            // Less than the screen\n            if (screenSize > scale * imageSize) {\n                if (width >= height) {\n                    nextTranslate = (screenSize - imageSize) / 2;\n                } else {\n                    nextTranslate =\n                        screenSize / 2 -\n                        (imageSize * (scale / imageInitialScale)) / 2;\n                }\n\n                return nextTranslate;\n            }\n\n            if (nextTranslate > leftLimit) {\n                nextTranslate = leftLimit;\n            }\n\n            if (nextTranslate < rightLimit) {\n                nextTranslate = rightLimit;\n            }\n\n            return nextTranslate;\n        };\n\n        return {x: getTranslate('x'), y: getTranslate('y')};\n    }\n\n    togglePanels(isVisible?: boolean) {\n        const panelsVisible =\n            typeof isVisible !== 'undefined'\n                ? isVisible\n                : !this.state.panelsVisible;\n        // toggle footer and header\n        this.setState({panelsVisible});\n\n        Animated.timing(this.headerTranslateValue.y, {\n            toValue: !panelsVisible ? -(HEADER_HEIGHT + 44) : 0,\n            duration: 200,\n            useNativeDriver: true,\n        }).start();\n\n        if (this.footerHeight > 0) {\n            Animated.timing(this.footerTranslateValue.y, {\n                toValue: !panelsVisible ? this.footerHeight : 0,\n                duration: 200,\n                useNativeDriver: true,\n            }).start();\n        }\n    }\n\n    listKeyExtractor = (image: ImageType): string =>\n        this.state.images.indexOf(image).toString();\n\n    close = () => {\n        this.setState({isVisible: false});\n\n        if (typeof this.props.onClose === 'function') {\n            this.props.onClose();\n        }\n    };\n\n    renderImage = ({item: image, index}: {item: *, index: number}): * => {\n        const loaded = image.loaded && image.width && image.height;\n\n        return (\n            <View\n                style={styles.imageContainer}\n                onStartShouldSetResponder={(): boolean => true}\n            >\n                <Animated.Image\n                    resizeMode=\"cover\"\n                    source={image.source}\n                    style={this.getImageStyle(image, index)}\n                    onLoad={(): void => this.onImageLoaded(index)}\n                    {...this.panResponder.panHandlers}\n                />\n                {!loaded && <ActivityIndicator style={styles.loading} />}\n            </View>\n        );\n    };\n\n    render(): Node {\n        const {animationType, renderFooter, backgroundColor} = this.props;\n        const {\n            images,\n            imageIndex,\n            imageScale,\n            isVisible,\n            scrollEnabled,\n        } = this.state;\n\n        const {close, prev, next} = this.getControls();\n        const imageInitialScale = this.getInitialScale();\n        const headerTranslate = this.headerTranslateValue.getTranslateTransform();\n        const footerTranslate = this.footerTranslateValue.getTranslateTransform();\n        const rgbBackgroundColor =\n            backgroundColor && isHex(backgroundColor)\n                ? hexToRgb(backgroundColor)\n                : defaultBackgroundColor;\n        const rgb = rgbBackgroundColor.join(',');\n        const animatedBackgroundColor = this.modalBackgroundOpacity.interpolate(\n            {\n                inputRange: [0, 1],\n                outputRange: [`rgba(${rgb}, 0.9)`, `rgba(${rgb}, 0.2)`],\n            }\n        );\n\n        const isPrevVisible =\n            imageScale === imageInitialScale && imageIndex > 0;\n        const isNextVisible =\n            imageScale === imageInitialScale && imageIndex < images.length - 1;\n\n        return (\n            <Modal\n                transparent\n                visible={isVisible}\n                animationType={animationType}\n                onRequestClose={this.close}\n                supportedOrientations={['portrait', 'landscape']}\n            >\n                <Animated.View\n                    style={[\n                        {backgroundColor: animatedBackgroundColor},\n                        styles.underlay,\n                    ]}\n                />\n                <Animated.View\n                    style={[\n                        styles.header,\n                        {\n                            transform: headerTranslate,\n                        },\n                    ]}\n                >\n                    <SafeAreaView style={{flex: 1}}>\n                        {!!close &&\n                            React.createElement(close, {onPress: this.close})}\n                    </SafeAreaView>\n                </Animated.View>\n                <FlatList\n                    horizontal\n                    pagingEnabled\n                    data={images}\n                    scrollEnabled={scrollEnabled}\n                    scrollEventThrottle={16}\n                    style={styles.container}\n                    ref={this.onFlatListRender}\n                    renderSeparator={() => null}\n                    keyExtractor={this.listKeyExtractor}\n                    onScroll={this.onNextImage}\n                    renderItem={this.renderImage}\n                    getItemLayout={this.getItemLayout}\n                    onMomentumScrollBegin={this.onMomentumScrollBegin}\n                    onMomentumScrollEnd={this.onMomentumScrollEnd}\n                />\n                {prev &&\n                    isPrevVisible &&\n                    React.createElement(prev, {onPress: this.scrollToPrev})}\n                {next &&\n                    isNextVisible &&\n                    React.createElement(next, {onPress: this.scrollToNext})}\n                {renderFooter && (\n                    <Animated.View\n                        style={[styles.footer, {transform: footerTranslate}]}\n                        onLayout={event => {\n                            this.footerHeight = event.nativeEvent.layout.height;\n                        }}\n                    >\n                        {typeof renderFooter === 'function' &&\n                            images[imageIndex] &&\n                            renderFooter(images[imageIndex])}\n                    </Animated.View>\n                )}\n            </Modal>\n        );\n    }\n}\n"]},"metadata":{},"sourceType":"module"}