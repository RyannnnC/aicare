{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport Image from \"react-native-web/dist/exports/Image\";\nimport PanResponder from \"react-native-web/dist/exports/PanResponder\";\nvar SCALE_EPSILON = 0.01;\nvar SCALE_MULTIPLIER = 1.2;\nexport var generatePanHandlers = function generatePanHandlers(onStart, onMove, onRelease) {\n  return PanResponder.create({\n    onStartShouldSetPanResponder: function onStartShouldSetPanResponder() {\n      return true;\n    },\n    onStartShouldSetPanResponderCapture: function onStartShouldSetPanResponderCapture() {\n      return true;\n    },\n    onMoveShouldSetPanResponder: function onMoveShouldSetPanResponder() {\n      return true;\n    },\n    onMoveShouldSetPanResponderCapture: function onMoveShouldSetPanResponderCapture() {\n      return true;\n    },\n    onPanResponderGrant: onStart,\n    onPanResponderMove: onMove,\n    onPanResponderRelease: onRelease,\n    onPanResponderTerminate: onRelease,\n    onPanResponderTerminationRequest: function onPanResponderTerminationRequest() {},\n    onShouldBlockNativeResponder: function onShouldBlockNativeResponder() {\n      return false;\n    }\n  });\n};\nexport var getScale = function getScale(currentDistance, initialDistance) {\n  return currentDistance / initialDistance * SCALE_MULTIPLIER;\n};\nexport var getDistance = function getDistance(touches) {\n  var _touches = _slicedToArray(touches, 2),\n      a = _touches[0],\n      b = _touches[1];\n\n  if (a == null || b == null) {\n    return 0;\n  }\n\n  return Math.sqrt(Math.pow(a.pageX - b.pageX, 2) + Math.pow(a.pageY - b.pageY, 2));\n};\nexport var calculateInitialScale = function calculateInitialScale() {\n  var imageWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var imageHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  var _ref = arguments.length > 2 ? arguments[2] : undefined,\n      screenWidth = _ref.screenWidth,\n      screenHeight = _ref.screenHeight;\n\n  var screenRatio = screenHeight / screenWidth;\n  var imageRatio = imageHeight / imageWidth;\n\n  if (imageWidth > screenWidth || imageHeight > screenHeight) {\n    if (screenRatio > imageRatio) {\n      return screenWidth / imageWidth;\n    }\n\n    return screenHeight / imageHeight;\n  }\n\n  return 1;\n};\nexport var calculateInitialTranslate = function calculateInitialTranslate() {\n  var imageWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var imageHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  var _ref2 = arguments.length > 2 ? arguments[2] : undefined,\n      screenWidth = _ref2.screenWidth,\n      screenHeight = _ref2.screenHeight;\n\n  var getTranslate = function getTranslate(axis) {\n    var imageSize = axis === 'x' ? imageWidth : imageHeight;\n    var screenSize = axis === 'x' ? screenWidth : screenHeight;\n\n    if (imageWidth >= imageHeight) {\n      return (screenSize - imageSize) / 2;\n    }\n\n    return screenSize / 2 - imageSize / 2;\n  };\n\n  return {\n    x: getTranslate('x'),\n    y: getTranslate('y')\n  };\n};\nexport var getInitialParams = function getInitialParams(_ref3, screenDimensions) {\n  var width = _ref3.width,\n      height = _ref3.height;\n  return {\n    scale: calculateInitialScale(width, height, screenDimensions),\n    translate: calculateInitialTranslate(width, height, screenDimensions)\n  };\n};\nexport function fetchImageSize() {\n  var images = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return images.reduce(function (acc, image) {\n    if (image.source && image.source.uri && (!image.width || !image.height)) {\n      var imageSize = new Promise(function (resolve, reject) {\n        Image.getSize(image.source.uri, function (width, height) {\n          return resolve({\n            width: width,\n            height: height,\n            index: image.index\n          });\n        }, reject);\n      });\n      acc.push(imageSize);\n    }\n\n    return acc;\n  }, []);\n}\nvar shortHexRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\nvar fullHexRegex = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i;\nexport var isHex = function isHex(color) {\n  return fullHexRegex.test(color) || shortHexRegex.test(color);\n};\nexport var hexToRgb = function hexToRgb(hex) {\n  var input = hex.replace(shortHexRegex, function (m, r, g, b) {\n    return \"\" + r + r + g + g + b + b;\n  });\n\n  var _concat = [].concat(fullHexRegex.exec(input)),\n      _concat2 = _slicedToArray(_concat, 4),\n      match = _concat2[0],\n      r = _concat2[1],\n      g = _concat2[2],\n      b = _concat2[3];\n\n  if (!match) {\n    return [];\n  }\n\n  return [parseInt(r, 16), parseInt(g, 16), parseInt(b, 16)];\n};\nexport var addIndexesToImages = function addIndexesToImages(images) {\n  return images.map(function (image, index) {\n    return _objectSpread(_objectSpread({}, image), {}, {\n      index: index\n    });\n  });\n};\nexport var getImagesWithoutSize = function getImagesWithoutSize(images) {\n  return images.filter(function (_ref4) {\n    var width = _ref4.width,\n        height = _ref4.height;\n    return !width || !height;\n  });\n};\nexport var scalesAreEqual = function scalesAreEqual(scaleA, scaleB) {\n  return Math.abs(scaleA - scaleB) < SCALE_EPSILON;\n};","map":{"version":3,"sources":["/Users/olivermou/Documents/GitHub/aicare/node_modules/react-native-image-view/src/utils.js"],"names":["SCALE_EPSILON","SCALE_MULTIPLIER","generatePanHandlers","onStart","onMove","onRelease","PanResponder","create","onStartShouldSetPanResponder","onStartShouldSetPanResponderCapture","onMoveShouldSetPanResponder","onMoveShouldSetPanResponderCapture","onPanResponderGrant","onPanResponderMove","onPanResponderRelease","onPanResponderTerminate","onPanResponderTerminationRequest","onShouldBlockNativeResponder","getScale","currentDistance","initialDistance","getDistance","touches","a","b","Math","sqrt","pow","pageX","pageY","calculateInitialScale","imageWidth","imageHeight","screenWidth","screenHeight","screenRatio","imageRatio","calculateInitialTranslate","getTranslate","axis","imageSize","screenSize","x","y","getInitialParams","screenDimensions","width","height","scale","translate","fetchImageSize","images","reduce","acc","image","source","uri","Promise","resolve","reject","Image","getSize","index","push","shortHexRegex","fullHexRegex","isHex","color","test","hexToRgb","hex","input","replace","m","r","g","concat","exec","match","parseInt","addIndexesToImages","map","getImagesWithoutSize","filter","scalesAreEqual","scaleA","scaleB","abs"],"mappings":"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","sourcesContent":["// @flow\nimport {Image, PanResponder} from 'react-native';\n\nimport {\n    type EventType,\n    type GestureState,\n    type ImageType,\n    type TouchType,\n    type TranslateType,\n    type TransitionType,\n    type DimensionsType,\n    type ScreenDimensionsType,\n} from './types';\n\nconst SCALE_EPSILON = 0.01;\nconst SCALE_MULTIPLIER = 1.2;\n\nexport const generatePanHandlers = (\n    onStart: (EventType, GestureState) => *,\n    onMove: (EventType, GestureState) => *,\n    onRelease: (EventType, GestureState) => *\n): * =>\n    PanResponder.create({\n        onStartShouldSetPanResponder: (): boolean => true,\n        onStartShouldSetPanResponderCapture: (): boolean => true,\n        onMoveShouldSetPanResponder: (): boolean => true,\n        onMoveShouldSetPanResponderCapture: (): boolean => true,\n        onPanResponderGrant: onStart,\n        onPanResponderMove: onMove,\n        onPanResponderRelease: onRelease,\n        onPanResponderTerminate: onRelease,\n        onPanResponderTerminationRequest: (): void => {},\n        onShouldBlockNativeResponder: () => false,\n    });\n\nexport const getScale = (\n    currentDistance: number,\n    initialDistance: number\n): number => (currentDistance / initialDistance) * SCALE_MULTIPLIER;\n\nexport const getDistance = (touches: Array<TouchType>): number => {\n    const [a, b] = touches;\n\n    if (a == null || b == null) {\n        return 0;\n    }\n\n    return Math.sqrt(\n        Math.pow(a.pageX - b.pageX, 2) + Math.pow(a.pageY - b.pageY, 2)\n    );\n};\n\nexport const calculateInitialScale = (\n    imageWidth: number = 0,\n    imageHeight: number = 0,\n    {screenWidth, screenHeight}: ScreenDimensionsType\n): number => {\n    const screenRatio = screenHeight / screenWidth;\n    const imageRatio = imageHeight / imageWidth;\n\n    if (imageWidth > screenWidth || imageHeight > screenHeight) {\n        if (screenRatio > imageRatio) {\n            return screenWidth / imageWidth;\n        }\n\n        return screenHeight / imageHeight;\n    }\n\n    return 1;\n};\n\nexport const calculateInitialTranslate = (\n    imageWidth: number = 0,\n    imageHeight: number = 0,\n    {screenWidth, screenHeight}: ScreenDimensionsType\n): TranslateType => {\n    const getTranslate = (axis: string): number => {\n        const imageSize = axis === 'x' ? imageWidth : imageHeight;\n        const screenSize = axis === 'x' ? screenWidth : screenHeight;\n\n        if (imageWidth >= imageHeight) {\n            return (screenSize - imageSize) / 2;\n        }\n\n        return screenSize / 2 - imageSize / 2;\n    };\n\n    return {\n        x: getTranslate('x'),\n        y: getTranslate('y'),\n    };\n};\n\nexport const getInitialParams = (\n    {width, height}: DimensionsType,\n    screenDimensions: Object\n): TransitionType => ({\n    scale: calculateInitialScale(width, height, screenDimensions),\n    translate: calculateInitialTranslate(width, height, screenDimensions),\n});\n\nexport function fetchImageSize(images: Array<ImageType> = []) {\n    return images.reduce((acc, image) => {\n        if (\n            image.source &&\n            image.source.uri &&\n            (!image.width || !image.height)\n        ) {\n            const imageSize = new Promise((resolve, reject) => {\n                Image.getSize(\n                    image.source.uri,\n                    (width, height) =>\n                        resolve({\n                            width,\n                            height,\n                            index: image.index,\n                        }),\n                    reject\n                );\n            });\n\n            acc.push(imageSize);\n        }\n\n        return acc;\n    }, []);\n}\n\nconst shortHexRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\nconst fullHexRegex = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i;\n\nexport const isHex = (color: string): boolean =>\n    fullHexRegex.test(color) || shortHexRegex.test(color);\n\nexport const hexToRgb = (hex: string): number[] => {\n    // Expand shorthand form (e.g. \"03F\") to full form (e.g. \"0033FF\")\n    const input = hex.replace(\n        shortHexRegex,\n        (m, r, g, b) => `${r}${r}${g}${g}${b}${b}`\n    );\n\n    const [match, r, g, b] = [].concat(fullHexRegex.exec(input));\n\n    if (!match) {\n        return [];\n    }\n\n    return [parseInt(r, 16), parseInt(g, 16), parseInt(b, 16)];\n};\n\nexport const addIndexesToImages = (images: ImageType[]): ImageType[] =>\n    images.map((image, index) => ({...image, index}));\n\nexport const getImagesWithoutSize = (images: ImageType[]) =>\n    images.filter(({width, height}) => !width || !height);\n\nexport const scalesAreEqual = (scaleA: number, scaleB: number): boolean =>\n    Math.abs(scaleA - scaleB) < SCALE_EPSILON;\n"]},"metadata":{},"sourceType":"module"}